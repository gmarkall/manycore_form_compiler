"""This module generates the code that extracts the relevant fields from
Fluidity state, transfers it to the GPU, and the run_model_ function that
executes the model for one timestep, by calling the kernels generated by
cudaform.py, and the necessary solves."""

# MCFC libs
from assembler import *
from codegeneration import *
import state
# FEniCS UFL libs
import ufl.finiteelement

class CudaAssemblerBackend(AssemblerBackend):

    def buildStateType(self):
	return Pointer(Class('StateHolder'))

    def buildState(self):
	t = self.buildStateType()
	state = Variable('state', t)
	decl = Declaration(state)
	return decl

    def buildInitialiser(self, ast, uflObjects):

        self._uflObjects = uflObjects

	func = FunctionDefinition(Void(), 'initialise_gpu_')
	func.setExternC(True)

	# Call the state constructor
	state = Variable('state')
	newState = New(Class('StateHolder'))
	construct = AssignmentOp(state, newState)
	func.append(construct)
	
	# Call the state initialiser
	call = FunctionCall('initialise')
	arrow = ArrowOp(state, call)
	func.append(arrow)

	# Extract accessed fields
	accessedFields = findAccessedFields(ast)
	for field in accessedFields:
	    fieldString = '"' + field + '"'
	    params = ExpressionList([Literal(fieldString)])
	    call = FunctionCall('extractField',params)
	    arrow = ArrowOp(state, call)
	    func.append(arrow)

	# Allocate memory and transfer to GPU
	call = FunctionCall('allocateAllGPUMemory')
	arrow = ArrowOp(state, call)
	func.append(arrow)

	call = FunctionCall('transferAllFields')
	arrow = ArrowOp(state, call)
	func.append(arrow)
	
	# Insert temporary fields into state
	solveResultFields = findSolveResults(ast)
	for field in solveResultFields:
	    similarField = self.findSimilarField(field)
	    similarFieldString = '"' + similarField + '"'
	    fieldString = '"' + field + '"'
	    params = ExpressionList([Literal(fieldString), Literal(similarFieldString)])
	    call = FunctionCall('insertTemporaryField',params)
	    arrow = ArrowOp(state, call)
	    func.append(arrow)

	# Get num_ele, num_nodes etc
        numEle = self.buildAndAppendNumEle(func)
	numNodes = self.buildAndAppendNumNodes(func)

        # Get sparsity of the field we're solving for
	sparsity = Variable('sparsity', Pointer(Class('CsrSparsity')))
	# We can use the similarFieldString from earlier, since its
	# the only field we're solving on for now. When we start working
	# with solving multiple fields, this logic will need re-working.
	# (For each solve field, we should use the similar field and
	# generate a new sparsity from that)
	params = ExpressionList([Literal(similarFieldString)])
	call = FunctionCall('getSparsity', params)
	arrow = ArrowOp(state, call)
	assignment = AssignmentOp(Declaration(sparsity), arrow)
	func.append(assignment)

        # Initialise matrix_colm, findrm, etc.
	# When you tidy this up, put these in a dict???
	matrixVars = [Variable('matrix_colm'), Variable('matrix_findrm'), \
	              Variable('matrix_colm_size'), Variable('matrix_findrm_size')]
	sourceFns  = ['getCudaColm', 'getCudaFindrm', 'getSizeColm', 'getSizeFindrm']

	for var, source in zip(matrixVars, sourceFns):
	    call = FunctionCall(source)
	    rhs = ArrowOp(sparsity, call)
	    assignment = AssignmentOp(var, rhs)
	    func.append(assignment)

        # Get the number of values per node and use it to calculate the
	# size of all the local vector entries. For now we'll use the same
	# logic as before, that we're only solving on one field, so we can
	# get these things from the last similar field that we found.
        numValsPerNode = Variable('numValsPerNode', Integer())
	params = ExpressionList([Literal(similarFieldString)])
	call = FunctionCall('getValsPerNode', params)
	lhs = Declaration(numValsPerNode)
        rhs = ArrowOp(state, call)
	assignment = AssignmentOp(lhs, rhs)
	func.append(assignment)
	
        numVectorEntries = Variable('numVectorEntries', Integer())
	params = ExpressionList([Literal(similarFieldString)])
	call = FunctionCall('getNodesPerEle', params)
	lhs = Declaration(numVectorEntries)
        rhs = ArrowOp(state, call)
	assignment = AssignmentOp(lhs, rhs)
	func.append(assignment)
	
        # Now multiply numVectorEntries by numValsPerNode to get the correct
	# size of the storage required
	mult = MultiplyOp(numVectorEntries, numValsPerNode)
	assignment = AssignmentOp(numVectorEntries, mult)
	func.append(assignment)

	# The space for the local matrix storage is simply the local vector
	# storage size squared. (I'm tired, some of these comments are a bit
	# nonsensey. note to self, tidy them up.)
	numMatrixEntries = Variable('numMatrixEntries', Integer())
	rhs = MultiplyOp(numVectorEntries, numVectorEntries)
	assignment = AssignmentOp(Declaration(numMatrixEntries), rhs)
	func.append(assignment)

	# Generate Mallocs for the local matrix and vector, and the solution
	# vector.
	localVector = Variable('localVector', Pointer(Real()))
	localMatrix = Variable('localMatrix', Pointer(Real()))
	globalVector = Variable('globalVector', Pointer(Real()))
	globalMatrix = Variable('globalMatrix', Pointer(Real()))
	solutionVector = Variable('solutionVector', Pointer(Real()))
	
	malloc = self.buildCudaMalloc(localVector, MultiplyOp(numEle, numVectorEntries))
	func.append(malloc)
	malloc = self.buildCudaMalloc(localMatrix, MultiplyOp(numEle, numMatrixEntries))
	func.append(malloc)
	malloc = self.buildCudaMalloc(globalVector, matrixVars[2]) # matrix_colm_size
	func.append(malloc)
	malloc = self.buildCudaMalloc(globalMatrix, MultiplyOp(numNodes, numValsPerNode))
	func.append(malloc)
	malloc = self.buildCudaMalloc(solutionVector,MultiplyOp(numNodes, numValsPerNode))
	func.append(malloc)

	return func

    def buildCudaMalloc(self, var, size):
        cast = Cast(Pointer(Pointer(Void())), AddressOfOp(var))
	sizeof = SizeOf(var.getType().getBaseType())
	sizeArg = MultiplyOp(sizeof, size)
        params = ExpressionList([cast, sizeArg])
        malloc = FunctionCall('cudaMalloc', params)
	return malloc

    def findSimilarField(self, field):
        obj = self._uflObjects[field]
	element = obj.element()
	degree = element.degree()
	
	if isinstance(element, ufl.finiteelement.FiniteElement):
	    sourceFields = state._finiteElements
	elif isinstance(element, ufl.finiteelement.FiniteElement):
	    sourceFields = state._vectorElements
	elif isinstance(element, ufl.finiteelement.FiniteElement):
	    sourceFields = state._tensorElements
	else:
	    print "Oops."

	for k in sourceFields:
	    if sourceFields[k] == degree:
	        return k
	
	print "Big oops."

    def buildFinaliser(self, ast, uflObjects):
        func = FunctionDefinition(Void(), 'finalise_gpu_')
	func.setExternC(True)

        state = Variable('state')
	delete = Delete(state)
	func.append(delete)

	return func

    def buildHeadersAndGlobals(self, ast, uflObjects):
        scope = GlobalScope()
	include = Include('cudastatic.hpp')
	scope.append(include)
	include = Include('cudastate.hpp')
	scope.append(include)

        # Bad copy-pasting from above. needs organising
	localVector = Variable('localVector', Pointer(Real()))
	localMatrix = Variable('localMatrix', Pointer(Real()))
	globalVector = Variable('globalVector', Pointer(Real()))
	globalMatrix = Variable('globalMatrix', Pointer(Real()))
	solutionVector = Variable('solutionVector', Pointer(Real()))
        
	# Some other variables to declare
	matrixColmSize = Variable('matrix_colm_size', Integer())
	matrixFindrmSize = Variable('matrix_findrm_size', Integer())
	matrixColm = Variable('matrix_colm', Pointer(Integer()))
	matrixFindrm = Variable('matrix_findrm', Pointer(Integer()))

        # Declare vars in global scope
        declVars = [localVector, localMatrix, globalVector, globalMatrix, solutionVector, \
	            matrixColmSize, matrixFindrmSize, matrixColm, matrixFindrm ]

        for var in declVars:
	    scope.append(Declaration(var))

        return scope

    def simpleBuildAndAppend(self, func, var, t, provider):
        state = Variable('state')
	varAst = Variable(var, t)
	call = FunctionCall('provider')
	arrow = ArrowOp(state, call)
	assignment = AssignmentOp(Declaration(varAst), arrow)
	func.append(assignment)
	return varAst

    def buildAndAppendNumEle(self, func):
	return self.simpleBuildAndAppend(func, 'numEle', Integer(), 'getNumEle')

    def buildAndAppendNumNodes(self, func):
	return self.simpleBuildAndAppend(func, 'numNodes', Integer(), 'getNumNodes')

    def buildAndAppendDetwei(self, func):
	return self.simpleBuildAndAppend(func, 'detwei', Pointer(Real()), 'getDetwei')

    def buildAndAppendEleNodes(self, func):
	return self.simpleBuildAndAppend(func, 'eleNodes', Pointer(Integer()), 'getEleNodes')

    def buildAndAppendCoordinates(self, func):
	return self.simpleBuildAndAppend(func, 'coordinates', Pointer(Real()), 'getCoordinates')

    def buildAndAppendDn(self, func):
	return self.simpleBuildAndAppend(func, 'dn', Pointer(Real()), 'getReferenceDn')
        
    def buildAndAppendQuadWeights(self, func):
	return self.simpleBuildAndAppend(func, 'quadWeights', Pointer(Real()), 'getQuadWeights')

    def buildRunModel(self, ast, uflObjects):
        func = FunctionDefinition(Void(), 'run_model_')
	func.setExternC(True)

        numEle = self.buildAndAppendNumEle(func)
	numNodes = self.buildAndAppendNumNodes(func)
        detwei = self.buildAndAppendDetwei(func)
        eleNodes = self.buildAndAppendEleNodes(func)
	coordinates = self.buildAndAppendCoordinates(func)
	dn = self.buildAndAppendDn(func)
	quadWeights = self.buildAndAppendQuadWeights(func)

	return func

"""This module generates the code that extracts the relevant fields from
Fluidity state, transfers it to the GPU, and the run_model_ function that
executes the model for one timestep, by calling the kernels generated by
cudaform.py, and the necessary solves."""

# MCFC libs
from assembler import *
from codegeneration import *
import state
# FEniCS UFL libs
import ufl.finiteelement

class CudaAssemblerBackend(AssemblerBackend):

    def buildStateType(self):
	return Pointer(Class('StateHolder'))

    def buildState(self):
	t = self.buildStateType()
	state = Variable('state', t)
	decl = Declaration(state)
	return decl

    def buildInitialiser(self, ast, uflObjects):

        self._uflObjects = uflObjects

	func = FunctionDefinition(Void(), 'initialise_gpu_')
	func.setExternC(True)

	# Call the state constructor
	state = Variable('state')
	newState = New(Class('StateHolder'))
	construct = AssignmentOp(state, newState)
	func.append(construct)
	
	# Call the state initialiser
	call = FunctionCall('initialise')
	arrow = ArrowOp(state, call)
	func.append(arrow)

	# Extract accessed fields
	accessedFields = findAccessedFields(ast)
	for field in accessedFields:
	    fieldString = '"' + field + '"'
	    params = ExpressionList([Literal(fieldString)])
	    call = FunctionCall('extractField',params)
	    arrow = ArrowOp(state, call)
	    func.append(arrow)

	# Allocate memory and transfer to GPU
	call = FunctionCall('allocateAllGPUMemory')
	arrow = ArrowOp(state, call)
	func.append(arrow)

	call = FunctionCall('transferAllFields')
	arrow = ArrowOp(state, call)
	func.append(arrow)
	
	# Insert temporary fields into state
	solveResultFields = findSolveResults(ast)
	for field in solveResultFields:
	    similarField = self.findSimilarField(field)
	    similarFieldString = '"' + similarField + '"'
	    fieldString = '"' + field + '"'
	    params = ExpressionList([Literal(fieldString), Literal(similarFieldString)])
	    call = FunctionCall('insertTemporaryField',params)
	    arrow = ArrowOp(state, call)
	    func.append(arrow)

	# Get num_ele, num_nodes etc
        numEle = Variable("numEle", Integer())
	call = FunctionCall('getNumEle')
        arrow = ArrowOp(state, call)
	assignment = AssignmentOp(Declaration(numEle), arrow)
	func.append(assignment)

        numNodes = Variable("numNodes", Integer())
	call = FunctionCall('getNumNodes')
        arrow = ArrowOp(state, call)
	assignment = AssignmentOp(Declaration(numNodes), arrow)
	func.append(assignment)

        # Get sparsity of the field we're solving for
	sparsity = Variable('sparsity', Pointer(Class('CsrSparsity')))
	# We can use the similarFieldString from earlier, since its
	# the only field we're solving on for now. When we start working
	# with solving multiple fields, this logic will need re-working.
	# (For each solve field, we should use the similar field and
	# generate a new sparsity from that)
	params = ExpressionList([Literal(similarFieldString)])
	call = FunctionCall('getSparsity', params)
	arrow = ArrowOp(state, call)
	assignment = AssignmentOp(Declaration(sparsity), arrow)
	func.append(assignment)

        # Initialise matrix_colm, findrm, etc.
	matrixVars = ['matrix_colm', 'matrix_findrm', 'matrix_colm_size', 'matrix_findrm_size']
	sourceFns  = ['getCudaColm', 'getCudaFindrm', 'getSizeColm',      'getSizeFindrm'     ]

	for var, source in zip(matrixVars, sourceFns):
	    lhs = Variable(var)
	    call = FunctionCall(source)
	    rhs = ArrowOp(sparsity, call)
	    assignment = AssignmentOp(lhs, rhs)
	    func.append(assignment)

        # Get the number of values per node and use it to calculate the
	# size of all the local vector entries. For now we'll use the same
	# logic as before, that we're only solving on one field, so we can
	# get these things from the last similar field that we found.
        numValsPerNode = Variable('numValsPerNode', Integer())
	params = ExpressionList([Literal(similarFieldString)])
	call = FunctionCall('getValsPerNode', params)
	lhs = Declaration(numValsPerNode)
        rhs = ArrowOp(state, call)
	assignment = AssignmentOp(lhs, rhs)
	func.append(assignment)
	
        numVectorEntries = Variable('numVectorEntries', Integer())
	params = ExpressionList([Literal(similarFieldString)])
	call = FunctionCall('getNodesPerEle', params)
	lhs = Declaration(numVectorEntries)
        rhs = ArrowOp(state, call)
	assignment = AssignmentOp(lhs, rhs)
	func.append(assignment)
	
        # Now multiply numVectorEntries by numValsPerNode to get the correct
	# size of the storage required
	mult = MultiplyOp(numVectorEntries, numValsPerNode)
	assignment = AssignmentOp(numVectorEntries, mult)
	func.append(assignment)

	# The space for the local matrix storage is simply the local vector
	# storage size squared. (I'm tired, some of these comments are a bit
	# nonsensey. note to self, tidy them up.)
	numMatrixEntries = Variable('numMatrixEntries', Integer())
	rhs = MultiplyOp(numVectorEntries, numVectorEntries)
	assignment = AssignmentOp(Declaration(numMatrixEntries), rhs)
	func.append(assignment)

	# Generate Mallocs for the local matrix and vector, and the solution
	# vector.

	return func

    def findSimilarField(self, field):
        obj = self._uflObjects[field]
	element = obj.element()
	degree = element.degree()
	
	if isinstance(element, ufl.finiteelement.FiniteElement):
	    sourceFields = state._finiteElements
	elif isinstance(element, ufl.finiteelement.FiniteElement):
	    sourceFields = state._vectorElements
	elif isinstance(element, ufl.finiteelement.FiniteElement):
	    sourceFields = state._tensorElements
	else:
	    print "Oops."

	for k in sourceFields:
	    if sourceFields[k] == degree:
	        return k
	
	print "Big oops."

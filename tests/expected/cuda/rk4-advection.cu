// Generated by the Manycore Form Compiler.
// https://github.com/gmarkall/manycore_form_compiler


#include "cudastatic.hpp"
#include "cudastate.hpp"
double* localVector;
double* localMatrix;
double* globalVector;
double* globalMatrix;
double* solutionVector;
int* Tracer_findrm;
int Tracer_findrm_size;
int* Tracer_colm;
int Tracer_colm_size;
int* t4_findrm;
int t4_findrm_size;
int* t4_colm;
int t4_colm_size;
int* t2_findrm;
int t2_findrm_size;
int* t2_colm;
int t2_colm_size;
int* t3_findrm;
int t3_findrm_size;
int* t3_colm;
int t3_colm_size;
int* t1_findrm;
int t1_findrm_size;
int* t1_colm;
int t1_colm_size;


__global__ void rhs3(double* localTensor, int n_ele, double dt, double* detwei, double* c1, double* c0, double* c2, double* CG1, double* d_CG1)
{
  double c_q1[12];
  double c_q0[6];
  double c_q2[6];
  double d_c_q1[24];
  for(int i_ele = THREAD_ID; i_ele < n_ele; i_ele += THREAD_COUNT)
  {
    for(int i_g = 0; i_g < 6; i_g++)
    {
      for(int i_d_0 = 0; i_d_0 < 2; i_d_0++)
      {
        c_q1[i_g + 6 * i_d_0] = 0.0;
        for(int i_r_0 = 0; i_r_0 < 3; i_r_0++)
        {
          c_q1[i_g + 6 * i_d_0] += c1[i_ele + n_ele * (i_d_0 + 2 * i_r_0)] * CG1[i_r_0 + 3 * i_g];
        };
      };
      c_q0[i_g] = 0.0;
      for(int i_r_0 = 0; i_r_0 < 3; i_r_0++)
      {
        c_q0[i_g] += c0[i_ele + n_ele * i_r_0] * CG1[i_r_0 + 3 * i_g];
      };
      c_q2[i_g] = 0.0;
      for(int i_r_0 = 0; i_r_0 < 3; i_r_0++)
      {
        c_q2[i_g] += c2[i_ele + n_ele * i_r_0] * CG1[i_r_0 + 3 * i_g];
      };
      for(int i_d_0 = 0; i_d_0 < 2; i_d_0++)
      {
        for(int i_d_1 = 0; i_d_1 < 2; i_d_1++)
        {
          d_c_q1[i_g + 6 * (i_d_0 + 2 * i_d_1)] = 0.0;
          for(int i_r_0 = 0; i_r_0 < 3; i_r_0++)
          {
            d_c_q1[i_g + 6 * (i_d_0 + 2 * i_d_1)] += c1[i_ele + n_ele * (i_d_0 + 2 * i_r_0)] * d_CG1[i_ele + n_ele * (i_d_0 + 2 * (i_g + 6 * i_r_0))];
          };
        };
      };
    };
    for(int i_r_0 = 0; i_r_0 < 3; i_r_0++)
    {
      localTensor[i_ele + n_ele * i_r_0] = 0.0;
      for(int i_g = 0; i_g < 6; i_g++)
      {
        for(int i_d_0 = 0; i_d_0 < 2; i_d_0++)
        {
          localTensor[i_ele + n_ele * i_r_0] += dt * (c_q1[i_g + 6 * i_d_0] * d_CG1[i_ele + n_ele * (i_d_0 + 2 * (i_g + 6 * i_r_0))] * (c_q0[i_g] + 0.5 * c_q2[i_g]) + -1 * d_c_q1[i_g + 6 * i_d_2] * CG1[i_r_0 + 3 * i_g] * (c_q0[i_g] + 0.5 * c_q2[i_g])) * detwei[i_ele + n_ele * i_g];
          for(int i_d_2 = 0; i_d_2 < 2; i_d_2++)
          {

          };
        };
      };
    };
  };
}

__global__ void M(double* localTensor, int n_ele, double dt, double* detwei, double* CG1)
{
  for(int i_ele = THREAD_ID; i_ele < n_ele; i_ele += THREAD_COUNT)
  {
    for(int i_r_0 = 0; i_r_0 < 3; i_r_0++)
    {
      for(int i_r_1 = 0; i_r_1 < 3; i_r_1++)
      {
        localTensor[i_ele + n_ele * (i_r_0 + 3 * i_r_1)] = 0.0;
        for(int i_g = 0; i_g < 6; i_g++)
        {
          localTensor[i_ele + n_ele * (i_r_0 + 3 * i_r_1)] += CG1[i_r_0 + 3 * i_g] * CG1[i_r_1 + 3 * i_g] * detwei[i_ele + n_ele * i_g];
        };
      };
    };
  };
}

__global__ void rhs4(double* localTensor, int n_ele, double dt, double* detwei, double* c1, double* c0, double* c2, double* CG1, double* d_CG1)
{
  double c_q1[12];
  double c_q0[6];
  double c_q2[6];
  double d_c_q1[24];
  for(int i_ele = THREAD_ID; i_ele < n_ele; i_ele += THREAD_COUNT)
  {
    for(int i_g = 0; i_g < 6; i_g++)
    {
      for(int i_d_0 = 0; i_d_0 < 2; i_d_0++)
      {
        c_q1[i_g + 6 * i_d_0] = 0.0;
        for(int i_r_0 = 0; i_r_0 < 3; i_r_0++)
        {
          c_q1[i_g + 6 * i_d_0] += c1[i_ele + n_ele * (i_d_0 + 2 * i_r_0)] * CG1[i_r_0 + 3 * i_g];
        };
      };
      c_q0[i_g] = 0.0;
      for(int i_r_0 = 0; i_r_0 < 3; i_r_0++)
      {
        c_q0[i_g] += c0[i_ele + n_ele * i_r_0] * CG1[i_r_0 + 3 * i_g];
      };
      c_q2[i_g] = 0.0;
      for(int i_r_0 = 0; i_r_0 < 3; i_r_0++)
      {
        c_q2[i_g] += c2[i_ele + n_ele * i_r_0] * CG1[i_r_0 + 3 * i_g];
      };
      for(int i_d_0 = 0; i_d_0 < 2; i_d_0++)
      {
        for(int i_d_1 = 0; i_d_1 < 2; i_d_1++)
        {
          d_c_q1[i_g + 6 * (i_d_0 + 2 * i_d_1)] = 0.0;
          for(int i_r_0 = 0; i_r_0 < 3; i_r_0++)
          {
            d_c_q1[i_g + 6 * (i_d_0 + 2 * i_d_1)] += c1[i_ele + n_ele * (i_d_0 + 2 * i_r_0)] * d_CG1[i_ele + n_ele * (i_d_0 + 2 * (i_g + 6 * i_r_0))];
          };
        };
      };
    };
    for(int i_r_0 = 0; i_r_0 < 3; i_r_0++)
    {
      localTensor[i_ele + n_ele * i_r_0] = 0.0;
      for(int i_g = 0; i_g < 6; i_g++)
      {
        for(int i_d_0 = 0; i_d_0 < 2; i_d_0++)
        {
          localTensor[i_ele + n_ele * i_r_0] += dt * (c_q1[i_g + 6 * i_d_0] * d_CG1[i_ele + n_ele * (i_d_0 + 2 * (i_g + 6 * i_r_0))] * (c_q0[i_g] + c_q2[i_g]) + -1 * d_c_q1[i_g + 6 * i_d_2] * CG1[i_r_0 + 3 * i_g] * (c_q0[i_g] + c_q2[i_g])) * detwei[i_ele + n_ele * i_g];
          for(int i_d_2 = 0; i_d_2 < 2; i_d_2++)
          {

          };
        };
      };
    };
  };
}

__global__ void rhs2(double* localTensor, int n_ele, double dt, double* detwei, double* c1, double* c0, double* c2, double* CG1, double* d_CG1)
{
  double c_q1[12];
  double c_q0[6];
  double c_q2[6];
  double d_c_q1[24];
  for(int i_ele = THREAD_ID; i_ele < n_ele; i_ele += THREAD_COUNT)
  {
    for(int i_g = 0; i_g < 6; i_g++)
    {
      for(int i_d_0 = 0; i_d_0 < 2; i_d_0++)
      {
        c_q1[i_g + 6 * i_d_0] = 0.0;
        for(int i_r_0 = 0; i_r_0 < 3; i_r_0++)
        {
          c_q1[i_g + 6 * i_d_0] += c1[i_ele + n_ele * (i_d_0 + 2 * i_r_0)] * CG1[i_r_0 + 3 * i_g];
        };
      };
      c_q0[i_g] = 0.0;
      for(int i_r_0 = 0; i_r_0 < 3; i_r_0++)
      {
        c_q0[i_g] += c0[i_ele + n_ele * i_r_0] * CG1[i_r_0 + 3 * i_g];
      };
      c_q2[i_g] = 0.0;
      for(int i_r_0 = 0; i_r_0 < 3; i_r_0++)
      {
        c_q2[i_g] += c2[i_ele + n_ele * i_r_0] * CG1[i_r_0 + 3 * i_g];
      };
      for(int i_d_0 = 0; i_d_0 < 2; i_d_0++)
      {
        for(int i_d_1 = 0; i_d_1 < 2; i_d_1++)
        {
          d_c_q1[i_g + 6 * (i_d_0 + 2 * i_d_1)] = 0.0;
          for(int i_r_0 = 0; i_r_0 < 3; i_r_0++)
          {
            d_c_q1[i_g + 6 * (i_d_0 + 2 * i_d_1)] += c1[i_ele + n_ele * (i_d_0 + 2 * i_r_0)] * d_CG1[i_ele + n_ele * (i_d_0 + 2 * (i_g + 6 * i_r_0))];
          };
        };
      };
    };
    for(int i_r_0 = 0; i_r_0 < 3; i_r_0++)
    {
      localTensor[i_ele + n_ele * i_r_0] = 0.0;
      for(int i_g = 0; i_g < 6; i_g++)
      {
        for(int i_d_0 = 0; i_d_0 < 2; i_d_0++)
        {
          localTensor[i_ele + n_ele * i_r_0] += dt * (c_q1[i_g + 6 * i_d_0] * d_CG1[i_ele + n_ele * (i_d_0 + 2 * (i_g + 6 * i_r_0))] * (c_q0[i_g] + 0.5 * c_q2[i_g]) + -1 * d_c_q1[i_g + 6 * i_d_2] * CG1[i_r_0 + 3 * i_g] * (c_q0[i_g] + 0.5 * c_q2[i_g])) * detwei[i_ele + n_ele * i_g];
          for(int i_d_2 = 0; i_d_2 < 2; i_d_2++)
          {

          };
        };
      };
    };
  };
}

__global__ void rhs1(double* localTensor, int n_ele, double dt, double* detwei, double* c0, double* c1, double* CG1, double* d_CG1)
{
  double c_q0[6];
  double c_q1[12];
  double d_c_q1[24];
  for(int i_ele = THREAD_ID; i_ele < n_ele; i_ele += THREAD_COUNT)
  {
    for(int i_g = 0; i_g < 6; i_g++)
    {
      c_q0[i_g] = 0.0;
      for(int i_r_0 = 0; i_r_0 < 3; i_r_0++)
      {
        c_q0[i_g] += c0[i_ele + n_ele * i_r_0] * CG1[i_r_0 + 3 * i_g];
      };
      for(int i_d_0 = 0; i_d_0 < 2; i_d_0++)
      {
        c_q1[i_g + 6 * i_d_0] = 0.0;
        for(int i_r_0 = 0; i_r_0 < 3; i_r_0++)
        {
          c_q1[i_g + 6 * i_d_0] += c1[i_ele + n_ele * (i_d_0 + 2 * i_r_0)] * CG1[i_r_0 + 3 * i_g];
        };
      };
      for(int i_d_0 = 0; i_d_0 < 2; i_d_0++)
      {
        for(int i_d_1 = 0; i_d_1 < 2; i_d_1++)
        {
          d_c_q1[i_g + 6 * (i_d_0 + 2 * i_d_1)] = 0.0;
          for(int i_r_0 = 0; i_r_0 < 3; i_r_0++)
          {
            d_c_q1[i_g + 6 * (i_d_0 + 2 * i_d_1)] += c1[i_ele + n_ele * (i_d_0 + 2 * i_r_0)] * d_CG1[i_ele + n_ele * (i_d_0 + 2 * (i_g + 6 * i_r_0))];
          };
        };
      };
    };
    for(int i_r_0 = 0; i_r_0 < 3; i_r_0++)
    {
      localTensor[i_ele + n_ele * i_r_0] = 0.0;
      for(int i_g = 0; i_g < 6; i_g++)
      {
        for(int i_d_0 = 0; i_d_0 < 2; i_d_0++)
        {
          localTensor[i_ele + n_ele * i_r_0] += dt * (c_q0[i_g] * c_q1[i_g + 6 * i_d_0] * d_CG1[i_ele + n_ele * (i_d_0 + 2 * (i_g + 6 * i_r_0))] + -1 * d_c_q1[i_g + 6 * i_d_2] * CG1[i_r_0 + 3 * i_g] * c_q0[i_g]) * detwei[i_ele + n_ele * i_g];
          for(int i_d_2 = 0; i_d_2 < 2; i_d_2++)
          {

          };
        };
      };
    };
  };
}

__global__ void ta(double* localTensor, int n_ele, double dt, double* detwei, double* c4, double* c3, double* c2, double* c0, double* c1, double* CG1)
{
  double c_q4[6];
  double c_q3[6];
  double c_q2[6];
  double c_q0[6];
  double c_q1[6];
  for(int i_ele = THREAD_ID; i_ele < n_ele; i_ele += THREAD_COUNT)
  {
    for(int i_g = 0; i_g < 6; i_g++)
    {
      c_q4[i_g] = 0.0;
      for(int i_r_0 = 0; i_r_0 < 3; i_r_0++)
      {
        c_q4[i_g] += c4[i_ele + n_ele * i_r_0] * CG1[i_r_0 + 3 * i_g];
      };
      c_q3[i_g] = 0.0;
      for(int i_r_0 = 0; i_r_0 < 3; i_r_0++)
      {
        c_q3[i_g] += c3[i_ele + n_ele * i_r_0] * CG1[i_r_0 + 3 * i_g];
      };
      c_q2[i_g] = 0.0;
      for(int i_r_0 = 0; i_r_0 < 3; i_r_0++)
      {
        c_q2[i_g] += c2[i_ele + n_ele * i_r_0] * CG1[i_r_0 + 3 * i_g];
      };
      c_q0[i_g] = 0.0;
      for(int i_r_0 = 0; i_r_0 < 3; i_r_0++)
      {
        c_q0[i_g] += c0[i_ele + n_ele * i_r_0] * CG1[i_r_0 + 3 * i_g];
      };
      c_q1[i_g] = 0.0;
      for(int i_r_0 = 0; i_r_0 < 3; i_r_0++)
      {
        c_q1[i_g] += c1[i_ele + n_ele * i_r_0] * CG1[i_r_0 + 3 * i_g];
      };
    };
    for(int i_r_0 = 0; i_r_0 < 3; i_r_0++)
    {
      localTensor[i_ele + n_ele * i_r_0] = 0.0;
      for(int i_g = 0; i_g < 6; i_g++)
      {
        localTensor[i_ele + n_ele * i_r_0] += (0.166666666667 * CG1[i_r_0 + 3 * i_g] * c_q4[i_g] + 0.333333333333 * CG1[i_r_0 + 3 * i_g] * c_q3[i_g] + 0.333333333333 * CG1[i_r_0 + 3 * i_g] * c_q2[i_g] + CG1[i_r_0 + 3 * i_g] * c_q0[i_g] + 0.166666666667 * CG1[i_r_0 + 3 * i_g] * c_q1[i_g]) * detwei[i_ele + n_ele * i_g];
      };
    };
  };
}

StateHolder* state;
extern "C" void initialise_gpu_()
{
  state = new StateHolder();
  state->initialise();
  state->extractField("Tracer", 0);
  state->extractField("Velocity", 1);
  state->allocateAllGPUMemory();
  state->transferAllFields();
  int numEle = state->getNumEle();
  int numNodes = state->getNumNodes();
  state->insertTemporaryField("t4", "Tracer");
  state->insertTemporaryField("t2", "Tracer");
  state->insertTemporaryField("t1", "Tracer");
  state->insertTemporaryField("t3", "Tracer");
  CsrSparsity* t1_sparsity = state->getSparsity("t1");
  t1_colm = t1_sparsity->getCudaColm();
  t1_findrm = t1_sparsity->getCudaFindrm();
  t1_colm_size = t1_sparsity->getSizeColm();
  t1_findrm_size = t1_sparsity->getSizeFindrm();
  CsrSparsity* t2_sparsity = state->getSparsity("t2");
  t2_colm = t2_sparsity->getCudaColm();
  t2_findrm = t2_sparsity->getCudaFindrm();
  t2_colm_size = t2_sparsity->getSizeColm();
  t2_findrm_size = t2_sparsity->getSizeFindrm();
  CsrSparsity* t3_sparsity = state->getSparsity("t3");
  t3_colm = t3_sparsity->getCudaColm();
  t3_findrm = t3_sparsity->getCudaFindrm();
  t3_colm_size = t3_sparsity->getSizeColm();
  t3_findrm_size = t3_sparsity->getSizeFindrm();
  CsrSparsity* t4_sparsity = state->getSparsity("t4");
  t4_colm = t4_sparsity->getCudaColm();
  t4_findrm = t4_sparsity->getCudaFindrm();
  t4_colm_size = t4_sparsity->getSizeColm();
  t4_findrm_size = t4_sparsity->getSizeFindrm();
  CsrSparsity* Tracer_sparsity = state->getSparsity("Tracer");
  Tracer_colm = Tracer_sparsity->getCudaColm();
  Tracer_findrm = Tracer_sparsity->getCudaFindrm();
  Tracer_colm_size = Tracer_sparsity->getSizeColm();
  Tracer_findrm_size = Tracer_sparsity->getSizeFindrm();
  int numValsPerNode = state->getValsPerNode("Tracer");
  int numVectorEntries = state->getNodesPerEle("Tracer");
  numVectorEntries = numVectorEntries * numValsPerNode;
  int numMatrixEntries = numVectorEntries * numVectorEntries;
  cudaMalloc((void**)(&localVector), sizeof(double) * numEle * numVectorEntries);
  cudaMalloc((void**)(&localMatrix), sizeof(double) * numEle * numMatrixEntries);
  cudaMalloc((void**)(&globalVector), sizeof(double) * numNodes * numValsPerNode);
  cudaMalloc((void**)(&globalMatrix), sizeof(double) * Tracer_colm_size);
  cudaMalloc((void**)(&solutionVector), sizeof(double) * numNodes * numValsPerNode);
}

extern "C" void finalise_gpu_()
{
  delete state;
}

extern "C" void run_model_(double* dt_pointer)
{
  double dt = *dt_pointer;
  int numEle = state->getNumEle();
  int numNodes = state->getNumNodes();
  double* detwei = state->getDetwei();
  int* eleNodes = state->getEleNodes();
  double* coordinates = state->getCoordinates();
  double* dn = state->getReferenceDn();
  double* quadWeights = state->getQuadWeights();
  int nDim = state->getDimension("Coordinate");
  int nQuad = state->getNumQuadPoints("Coordinate");
  int nodesPerEle = state->getNodesPerEle("Coordinate");
  double* shape = state->getBasisFunction("Coordinate");
  double* dShape = state->getBasisFunctionDerivative("Coordinate");
  int blockXDim = 64;
  int gridXDim = 128;
  int shMemSize = t2p_shmemsize(blockXDim, nDim, nodesPerEle);
  transform_to_physical<<<gridXDim,blockXDim,shMemSize>>>(coordinates, dn, quadWeights, dShape, detwei, numEle, nDim, nQuad, nodesPerEle);
  M<<<gridXDim,blockXDim>>>(localMatrix, numEle, dt, detwei, shape);
  double* TracerCoeff = state->getElementValue("Tracer");
  double* VelocityCoeff = state->getElementValue("Velocity");
  rhs1<<<gridXDim,blockXDim>>>(localVector, numEle, dt, detwei, TracerCoeff, VelocityCoeff, shape, dShape);
  cudaMemset(globalMatrix, 0, sizeof(double) * t1_colm_size);
  cudaMemset(globalVector, 0, sizeof(double) * state->getValsPerNode("t1") * numNodes);
  matrix_addto<<<gridXDim,blockXDim>>>(t1_findrm, t1_colm, globalMatrix, eleNodes, localMatrix, numEle, nodesPerEle);
  vector_addto<<<gridXDim,blockXDim>>>(globalVector, eleNodes, localVector, numEle, nodesPerEle);
  cg_solve(t1_findrm, t1_findrm_size, t1_colm, t1_colm_size, globalMatrix, globalVector, numNodes, solutionVector);
  double* t1Coeff = state->getElementValue("t1");
  expand_data<<<gridXDim,blockXDim>>>(t1Coeff, solutionVector, eleNodes, numEle, state->getValsPerNode("t1"), nodesPerEle);
  M<<<gridXDim,blockXDim>>>(localMatrix, numEle, dt, detwei, shape);
  rhs2<<<gridXDim,blockXDim>>>(localVector, numEle, dt, detwei, VelocityCoeff, TracerCoeff, t1Coeff, shape, dShape);
  cudaMemset(globalMatrix, 0, sizeof(double) * t2_colm_size);
  cudaMemset(globalVector, 0, sizeof(double) * state->getValsPerNode("t2") * numNodes);
  matrix_addto<<<gridXDim,blockXDim>>>(t2_findrm, t2_colm, globalMatrix, eleNodes, localMatrix, numEle, nodesPerEle);
  vector_addto<<<gridXDim,blockXDim>>>(globalVector, eleNodes, localVector, numEle, nodesPerEle);
  cg_solve(t2_findrm, t2_findrm_size, t2_colm, t2_colm_size, globalMatrix, globalVector, numNodes, solutionVector);
  double* t2Coeff = state->getElementValue("t2");
  expand_data<<<gridXDim,blockXDim>>>(t2Coeff, solutionVector, eleNodes, numEle, state->getValsPerNode("t2"), nodesPerEle);
  M<<<gridXDim,blockXDim>>>(localMatrix, numEle, dt, detwei, shape);
  rhs3<<<gridXDim,blockXDim>>>(localVector, numEle, dt, detwei, VelocityCoeff, TracerCoeff, t2Coeff, shape, dShape);
  cudaMemset(globalMatrix, 0, sizeof(double) * t3_colm_size);
  cudaMemset(globalVector, 0, sizeof(double) * state->getValsPerNode("t3") * numNodes);
  matrix_addto<<<gridXDim,blockXDim>>>(t3_findrm, t3_colm, globalMatrix, eleNodes, localMatrix, numEle, nodesPerEle);
  vector_addto<<<gridXDim,blockXDim>>>(globalVector, eleNodes, localVector, numEle, nodesPerEle);
  cg_solve(t3_findrm, t3_findrm_size, t3_colm, t3_colm_size, globalMatrix, globalVector, numNodes, solutionVector);
  double* t3Coeff = state->getElementValue("t3");
  expand_data<<<gridXDim,blockXDim>>>(t3Coeff, solutionVector, eleNodes, numEle, state->getValsPerNode("t3"), nodesPerEle);
  M<<<gridXDim,blockXDim>>>(localMatrix, numEle, dt, detwei, shape);
  rhs4<<<gridXDim,blockXDim>>>(localVector, numEle, dt, detwei, VelocityCoeff, TracerCoeff, t3Coeff, shape, dShape);
  cudaMemset(globalMatrix, 0, sizeof(double) * t4_colm_size);
  cudaMemset(globalVector, 0, sizeof(double) * state->getValsPerNode("t4") * numNodes);
  matrix_addto<<<gridXDim,blockXDim>>>(t4_findrm, t4_colm, globalMatrix, eleNodes, localMatrix, numEle, nodesPerEle);
  vector_addto<<<gridXDim,blockXDim>>>(globalVector, eleNodes, localVector, numEle, nodesPerEle);
  cg_solve(t4_findrm, t4_findrm_size, t4_colm, t4_colm_size, globalMatrix, globalVector, numNodes, solutionVector);
  double* t4Coeff = state->getElementValue("t4");
  expand_data<<<gridXDim,blockXDim>>>(t4Coeff, solutionVector, eleNodes, numEle, state->getValsPerNode("t4"), nodesPerEle);
  M<<<gridXDim,blockXDim>>>(localMatrix, numEle, dt, detwei, shape);
  ta<<<gridXDim,blockXDim>>>(localVector, numEle, dt, detwei, t4Coeff, t3Coeff, t2Coeff, TracerCoeff, t1Coeff, shape);
  cudaMemset(globalMatrix, 0, sizeof(double) * Tracer_colm_size);
  cudaMemset(globalVector, 0, sizeof(double) * state->getValsPerNode("Tracer") * numNodes);
  matrix_addto<<<gridXDim,blockXDim>>>(Tracer_findrm, Tracer_colm, globalMatrix, eleNodes, localMatrix, numEle, nodesPerEle);
  vector_addto<<<gridXDim,blockXDim>>>(globalVector, eleNodes, localVector, numEle, nodesPerEle);
  cg_solve(Tracer_findrm, Tracer_findrm_size, Tracer_colm, Tracer_colm_size, globalMatrix, globalVector, numNodes, solutionVector);
  expand_data<<<gridXDim,blockXDim>>>(TracerCoeff, solutionVector, eleNodes, numEle, state->getValsPerNode("Tracer"), nodesPerEle);
  state->returnFieldToHost("Tracer");
}



